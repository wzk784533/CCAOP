#!/usr/bin/env python
import sys, getopt,os

def showUsage():
	print "*"*120	
	print "Usage:"
	print "ccaop.py -h headfile -n namespace -f function -l libname -o cppfilename"
	print "-h or --headfile  : header file which contains the definition of you class"
	print "-n or --namespace : namespace where your class defined in"
	print "-f or --function  : member function you want to hook, using double quotes like:\"int foo::bar(a,b,...)\""
	print "-l or --libname   : dynamic lib which contains the member function you want to hook"
	print "-o or --cppfile   : boilerplate cpp file name you want to generate"
	print "*"*120	
	print "Of all the arguments, only the namespace can be omitted. In this case, the hook lib will use global namespace."
	print "*"*120	
	sys.exit(1)


def getSysOption():
	try:
		opts,args=getopt.getopt(sys.argv[1:],"sh:n:c:f:o:l:",["headfile=","namespace=","function=","libname=","cppname="])
	except getopt.GetoptError:
		showUsage()
		
		
	if len(opts)==0:
		showUsage()
	
	optionMap=dict.fromkeys(['headfile','namespace','function','cppname','libname'],None)
	for opt, arg in opts:
		if opt=='s':
			showUsage()
		
		if opt in('-h','headfile'):
			optionMap['headfile']=arg
		
		if opt in('-n','namespace'):
			optionMap['namespace']=arg
		
		if opt in('-f','function'):
			optionMap['function']=arg
		
		if opt in('-o','cppname'):
			optionMap['cppname']=arg
		
		if opt in('-l','libname'):
			optionMap['libname']=arg
	
	emptyOpt=filter(lambda x:not optionMap[x],optionMap)
	if not emptyOpt or emptyOpt==["namespace"]:
		return optionMap
	else:
		return showUsage()
	
def showSysoption(option):
	print "Generating the boilerplate code for your aop library..."
	print "Using these options:"
	for x in option:
		value=option[x] or " "
		print "** "+x+"\t: "+value

def analyzeFunction(functionName):
	arguments=functionName.split("(")[1].strip(')')
	classname=functionName.split("::")[0].split(' ')[-1]
	returntype=functionName.split("::")[0].split(' ')[0:-1]
	funcName=functionName.split("::")[1].split('(')[0].strip()
	return returntype,classname,funcName,arguments
	


#generate c++ name mangling function name
#using nm command and grep in shell
#this implemention is ugly, will fix someday later
def generateCppFuncName(libname,namespace,classname,function):
	command=None
	if not namespace:
		command="nm %s | grep %s | grep %s | grep T | awk '{print $3}'"%(libname,classname,function)
	else:
		command="nm %s | grep %s | grep %s | grep %s | grep T | awk '{print $3}'"%(libname,namespace,classname,function)
	result=os.popen(command).read().strip().split("\n")
	for func in result:
		command="c++filt "+func
		realfunc=os.popen(command).read()
		print "Are you gonna hook this function ?\n\n"+realfunc+"\n\n"
		while True:
			confirm=raw_input("if it is the right function press y,else press other key:")			
			if not confirm.strip():
				continue
			if confirm.upper()=='Y':
				return func
			else:
				break
	
def generateBoilerplateCode(option):
	include='''//code generated by ccaop
//https://github.com/wzk784533/CCAOP
#include <iostream>
#include <string>
/*
you can comment the header files above,
if you don't need it in you aop library
*/
#include <dlfcn.h>
#include "%s"
/*
In some complex system, you might need some more other head files,which defines the class in your function paramater.
Before compling this code,you must include these head files, avoiding type declariton error complains in complier.
*/
using namespace std;
'''%option["headfile"]
	
	returntype,classname,funcName,arguments=analyzeFunction(option["function"])
	namemangling=generateCppFuncName(option["libname"],option["namespace"],classname,funcName)	
	
	function='''
%s
{
   typedef %s (*pFunc)(%s *,%s);
   static void *handle = NULL;
   static void *func = NULL;
   if(!func)
   {
      handle = dlopen("%s", RTLD_LAZY);
      func=dlsym(handle,"%s");
      dlclose(handle);
   }
   /* AOP before */
   /* your code starts here */
		
		
   //real function call
   pFunc realFunc=(pFunc)(func);
   %s result=realFunc(this%s);
		
   /* AOP after */
   /* your code starts here */
		
   return result;
}
'''%(option["function"],' '.join(returntype),classname,arguments,option["libname"],namemangling,' '.join(returntype),'' if not arguments else ','+arguments)
	
	with open(option["cppname"],'w+') as f:
		f.write(include+function)

if __name__=="__main__":
	options=getSysOption()
	showSysoption(options)
	generateBoilerplateCode(options)
	


	
	
	
	

